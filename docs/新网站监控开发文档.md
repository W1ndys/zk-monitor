# 新网站监控开发文档

本文档介绍如何为监控框架添加新的网站监控器或通知渠道。

---

## 项目结构

```
山东省研究生招考监控/
├── config.yaml                # 监控器与通知器声明配置
├── main.py                    # 入口文件
├── framework/
│   ├── models.py              # Notice 数据模型
│   ├── monitor.py             # BaseMonitor 监控器基类
│   ├── notifier.py            # BaseNotifier 通知器基类
│   ├── storage.py             # 按监控器隔离的 JSON 存储
│   └── runner.py              # 核心调度逻辑
├── monitors/
│   └── sdzk_yzk.py           # 山东省研究生招考监控（示例）
├── notifiers/
│   ├── feishu.py              # 飞书通知器
│   └── onebot.py              # OneBot (QQ) 通知器
├── data/                      # 运行时数据（已 gitignore）
└── logs/                      # 运行时日志（已 gitignore）
```

---

## 核心概念

### Notice 数据模型

所有监控器返回统一的 `Notice` 对象，通过 `url` 字段去重：

```python
from framework.models import Notice

notice = Notice(
    title="关于做好2025年硕士研究生招生考试工作的通知",
    url="https://www.sdzk.cn/NewsInfo.aspx?NewsID=1234",
    date="2025-01-15",
)
```

### 运行流程

对每个监控器，框架执行以下流程：

1. **抓取** — 调用 `monitor.fetch()` 获取当前通知列表
2. **对比** — 与 `data/{monitor.name}.json` 中的历史记录对比，找出新增通知
3. **通知** — 将新通知依次发送到所有已配置的通知器
4. **存储** — 更新本地 JSON 文件

首次运行时（本地无历史数据），框架会向所有通知器发送测试消息验证连通性，然后保存当前通知作为基线，不触发通知推送。

---

## 添加新的网站监控器

### 第一步：创建监控器文件

在 `monitors/` 目录下创建 Python 文件，例如 `monitors/my_site.py`：

```python
from __future__ import annotations

import requests
from bs4 import BeautifulSoup
from loguru import logger

from framework.models import Notice
from framework.monitor import BaseMonitor


class MySiteMonitor(BaseMonitor):
    """我的网站监控器。"""

    name = "my_site"               # 唯一标识，用于存储文件名 data/my_site.json
    display_name = "我的网站"       # 人类可读名称，显示在通知消息中

    def __init__(self, url: str = "https://example.com/notices") -> None:
        self.url = url

    def fetch(self) -> list[Notice]:
        """抓取目标页面，返回通知列表。"""
        logger.info(f"正在请求: {self.url}")
        resp = requests.get(self.url, timeout=15)
        resp.encoding = "utf-8"
        resp.raise_for_status()

        soup = BeautifulSoup(resp.text, "html.parser")

        notices: list[Notice] = []
        # 根据目标网站的 HTML 结构编写解析逻辑
        for item in soup.select("ul.notice-list li"):
            title = item.select_one("a").get_text(strip=True)
            url = item.select_one("a")["href"]
            date = item.select_one(".date").get_text(strip=True)
            notices.append(Notice(title=title, url=url, date=date))

        logger.info(f"共获取到 {len(notices)} 条通知")
        return notices
```

### 第二步：在 config.yaml 中注册

```yaml
monitors:
  # 已有的监控器
  - class: monitors.sdzk_yzk.SdzkYzkMonitor
    args:
      url: "https://www.sdzk.cn/NewsList.aspx?BCID=25&CID=1124"

  # 新增的监控器
  - class: monitors.my_site.MySiteMonitor
    args:
      url: "https://example.com/notices"
```

`args` 下的所有参数会以关键字参数形式传入监控器的 `__init__` 方法。如果 `__init__` 没有额外参数，`args` 可以省略。

### 完成

无需修改框架代码或通知器代码。运行 `uv run python main.py` 即可生效。

---

## 添加新的通知渠道

### 第一步：创建通知器文件

在 `notifiers/` 目录下创建 Python 文件，例如 `notifiers/dingtalk.py`：

```python
from __future__ import annotations

import os

import requests
from loguru import logger

from framework.models import Notice
from framework.notifier import BaseNotifier


class DingTalkNotifier(BaseNotifier):
    """钉钉 Webhook 通知器。"""

    name = "dingtalk"

    def __init__(self) -> None:
        # 敏感信息从环境变量读取，不要写在代码或 config.yaml 中
        self.webhook = os.getenv("DINGTALK_WEBHOOK", "")

    def send(self, monitor_name: str, notices: list[Notice]) -> bool:
        """发送新通知到钉钉群。成功返回 True。"""
        if not self.webhook:
            logger.warning("未配置 DINGTALK_WEBHOOK，跳过钉钉推送")
            return False

        lines = [f"**{monitor_name}新通知（{len(notices)}条）**\n"]
        for n in notices:
            lines.append(f"- [{n.title}]({n.url})  {n.date}")
        text = "\n".join(lines)

        body = {
            "msgtype": "markdown",
            "markdown": {"title": f"{monitor_name}新通知", "text": text},
        }
        try:
            resp = requests.post(self.webhook, json=body, timeout=10)
            result = resp.json()
            if result.get("errcode") == 0:
                logger.info("钉钉消息发送成功")
                return True
            else:
                logger.error(f"钉钉消息发送失败: {result}")
                return False
        except Exception as e:
            logger.error(f"钉钉消息发送异常: {e}")
            return False

    def test(self, monitor_name: str) -> bool:
        """发送钉钉测试消息，验证连通性。"""
        if not self.webhook:
            logger.warning("未配置 DINGTALK_WEBHOOK，跳过连通性测试")
            return False
        logger.info("正在发送钉钉测试消息...")
        body = {
            "msgtype": "text",
            "text": {"content": f"【{monitor_name}监控】初始化测试成功，监控服务已启动。"},
        }
        try:
            resp = requests.post(self.webhook, json=body, timeout=10)
            result = resp.json()
            ok = result.get("errcode") == 0
            if ok:
                logger.info("钉钉连通性测试通过")
            else:
                logger.error(f"钉钉连通性测试失败: {result}")
            return ok
        except Exception as e:
            logger.error(f"钉钉连通性测试异常: {e}")
            return False
```

### 第二步：配置环境变量

在 `.env` 中添加敏感配置：

```
DINGTALK_WEBHOOK=https://oapi.dingtalk.com/robot/send?access_token=xxxxxxxx
```

同时更新 `.env.example` 作为模板。

### 第三步：在 config.yaml 中注册

```yaml
notifiers:
  - class: notifiers.feishu.FeishuNotifier
  - class: notifiers.onebot.OneBotNotifier
  - class: notifiers.dingtalk.DingTalkNotifier   # 新增
```

### 完成

无需修改框架代码或监控器代码。所有监控器的新通知会自动推送到新渠道。

---

## 开发注意事项

### name 字段

- **监控器的 `name`** 必须全局唯一，它决定了存储文件名（`data/{name}.json`）和日志前缀。建议使用小写字母 + 下划线格式，如 `sdzk_yzk`。
- **通知器的 `name`** 用于日志标识，建议简短有意义，如 `feishu`、`onebot`。

### 敏感信息

- Webhook 地址、Token、密钥等敏感信息**必须**通过 `.env` 环境变量传入，**不要**写在 `config.yaml` 或代码中。
- `config.yaml` 只存放类路径和非敏感参数（如目标 URL），可以安全提交到版本控制。

### 去重逻辑

- 框架通过 `Notice.url` 进行去重。确保 `fetch()` 返回的每条通知的 `url` 是稳定且唯一的。
- 如果目标网站的链接中包含会变化的参数（如时间戳），需要在 `fetch()` 中清洗 URL。

### 错误处理

- `fetch()` 中如果抛出异常，框架会捕获并记录日志，跳过该监控器，继续执行其他监控器。
- `send()` 和 `test()` 中如果抛出异常，框架同样会捕获。建议在方法内部做好 try/except，返回 `False` 表示失败。

### 首次运行

- 每个监控器独立判断首次运行（检查 `data/{name}.json` 是否存在）。
- 首次运行时会触发所有通知器的 `test()` 方法，如果任一通知器测试失败，则不保存基线数据，下次运行仍会当作首次运行处理。
- 如需重新触发首次运行，删除对应的 `data/{name}.json` 文件即可。

### 本地测试

```bash
# 安装依赖
uv sync

# 删除某个监控器的历史数据以触发首次运行
rm data/my_site.json

# 运行
uv run python main.py
```

---

## 现有监控器参考

| 监控器 | 文件 | name | 目标网站 |
|--------|------|------|----------|
| 山东省研究生招考 | `monitors/sdzk_yzk.py` | `sdzk_yzk` | sdzk.cn 研究生招考通知 |

## 现有通知器参考

| 通知器 | 文件 | name | 环境变量 |
|--------|------|------|----------|
| 飞书 | `notifiers/feishu.py` | `feishu` | `FEISHU_WEBHOOK`, `FEISHU_SECRET` |
| OneBot (QQ) | `notifiers/onebot.py` | `onebot` | `ONEBOT_HTTP_URL`, `ONEBOT_ACCESS_TOKEN`, `ONEBOT_GROUP_IDS` |
